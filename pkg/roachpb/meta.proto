// Copyright 2020 The Cockroach Authors.
//
// Use of this software is governed by the Business Source License
// included in the file licenses/BSL.txt.
//
// As of the Change Date specified in that file, in accordance with
// the Business Source License, use of this software will be governed
// by the Apache License, Version 2.0, included in the file
// licenses/APL.txt.

syntax = "proto3";
package cockroach.roachpb;
option go_package = "roachpb";

import "gogoproto/gogo.proto";
import "google/protobuf/any.proto";

message Event {
  int64 start_ns = 1;
  int64 end_ns = 2;
  // TODO(tbg): alternative would be a oneof that would then be KV specific
  // (or become a Cockroach-global singleton). This would be mildly more
  // performant but - I think - would result in poorer interfaces as we
  // would be unable to provide infrastructure around these events in
  // a small self-contained pkg. On the other hand, if we end up returning
  // more events in the hot path (as we might want to) we need the special
  // casing anyway. Maybe there's a middle ground? Each "subsystem" (KV, etc)
  // gets a subsystem-specific message that is a oneof of all possible events,
  // and that message itself is what gets send back in traces (but on the batch
  // response, it's embedded via its concrete type).
  google.protobuf.Any details = 3 [(gogoproto.nullable) = false]; // ContentionEvent, etc
}

// These would live in a kv-specific package

message ContentionEvent {
  bytes key = 1 [(gogoproto.customtype) = "Key"];
  bool pushee_aborted = 3; // did pushee commit or abort?
}

message RequestLifecycleEvent {
  int64 sequenced = 2; // past latch mgr
  int64 proposed = 3; // put into raft
  int64 applied = 4; // response from raft = end of processing
}

message Meta {
  RequestLifecycleEvent lifecycle = 1 [(gogoproto.embed) = true];
  repeated Event events = 2 [(gogoproto.nullable) = false];
}
